<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Focusable Image Distributor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            user-select: none;
        }
        
        #moodboard {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            gap: 1px;
            transition: filter 0.3s ease;
        }
        
        #moodboard.blurred {
            filter: blur(5px);
        }
        
        .image-container {
            position: relative;
            overflow: hidden;
            background: #111;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .image-container:hover {
            transform: scale(1.02);
            z-index: 10;
        }
        
        .image-container.focused {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(1.1);
            width: 90vw;
            height: 90vh;
            z-index: 1000;
            cursor: zoom-out;
            box-shadow: 0 0 100px rgba(0, 0, 0, 0.8);
            border-radius: 10px;
        }
        
        .image-container.focused img {
            border-radius: 10px;
        }
        
        .image-container.dragging {
            opacity: 0.5;
            cursor: grabbing;
            z-index: 100;
        }
        
        .image-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            pointer-events: none;
            transition: all 0.3s ease;
        }
        
        /* Minimal UI */
        #ui-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        body:hover #ui-container {
            opacity: 1;
        }
        
        #top-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, transparent 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .image-controls {
            position: absolute;
            top: 5px;
            right: 5px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: auto;
            z-index: 10;
        }
        
        .image-container:hover .image-controls,
        .image-controls:hover {
            opacity: 1;
        }
        
        .image-container.focused .image-controls {
            opacity: 1;
            top: 15px;
            right: 15px;
        }
        
        .image-controls button {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            margin-left: 5px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        .image-controls button:hover {
            background: rgba(200, 0, 0, 0.8);
            transform: scale(1.1);
        }
        
        .image-controls button.focus-btn {
            background: rgba(0, 100, 200, 0.7);
        }
        
        .image-controls button.focus-btn:hover {
            background: rgba(0, 150, 255, 0.8);
        }
        
        #status {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 8px;
            text-align: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            font-size: 0.9rem;
        }
        
        #status.show {
            opacity: 1;
        }
        
        /* Drag overlay for external drags */
        #drag-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 100, 255, 0.1);
            border: 3px dashed #0099ff;
            z-index: 10000;
            display: none;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            color: white;
            pointer-events: none;
        }
        
        #drag-overlay.active {
            display: flex;
        }
        
        /* Navigation arrows for focused image */
        .nav-arrow {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            font-size: 24px;
            cursor: pointer;
            z-index: 1001;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .nav-arrow:hover {
            background: rgba(0, 0, 0, 0.8);
            transform: translateY(-50%) scale(1.1);
        }
        
        .nav-arrow.left {
            left: 20px;
        }
        
        .nav-arrow.right {
            right: 20px;
        }
        
        .image-container.focused ~ .nav-arrow {
            display: flex;
        }
        
        /* Close button for focused image */
        .close-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            z-index: 1001;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .close-btn:hover {
            background: rgba(200, 0, 0, 0.8);
            transform: scale(1.1);
        }
        
        .image-container.focused ~ .close-btn {
            display: flex;
        }
        
        /* Image counter for focused mode */
        .image-counter {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1001;
            display: none;
        }
        
        .image-container.focused ~ .image-counter {
            display: block;
        }
    </style>
</head>
<body>
    <div id="moodboard"></div>
    <div id="drag-overlay">Drop image here</div>
    
    <div id="ui-container">
        <div id="top-ui">
            <div>Paste images (Ctrl+V) or drag images | Click to focus | Drag to reorder | Ctrl+Delete to clear all</div>
        </div>
    </div>
    
    <div id="status"></div>
    
    <!-- Navigation elements (hidden by default) -->
    <button class="nav-arrow left" onclick="navigateFocus(-1)">‹</button>
    <button class="nav-arrow right" onclick="navigateFocus(1)">›</button>
    <button class="close-btn" onclick="closeFocus()">×</button>
    <div class="image-counter" id="imageCounter">1 / 1</div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const moodboard = document.getElementById('moodboard');
            const status = document.getElementById('status');
            const dragOverlay = document.getElementById('drag-overlay');
            const imageCounter = document.getElementById('imageCounter');
            
            let images = [];
            let draggedIndex = null;
            let dragStartX = 0;
            let dragStartY = 0;
            let focusedIndex = -1;
            const DRAG_THRESHOLD = 5;
            
            // Show status message
            function showStatus(message, duration = 1500) {
                status.textContent = message;
                status.classList.add('show');
                
                setTimeout(() => {
                    status.classList.remove('show');
                }, duration);
            }
            
            // Perfect grid calculation - NO BLACK ROWS
            function calculatePerfectLayout(count) {
                if (count === 0) return { cols: 1, rows: 1, areas: [] };
                if (count === 1) return { cols: 1, rows: 1, areas: ['1 / 1 / 2 / 2'] };
                
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                const screenAspect = screenWidth / screenHeight;
                
                let bestCols = 1;
                let bestRows = 1;
                let bestScore = Infinity;
                let bestAreas = [];
                
                for (let cols = 1; cols <= count; cols++) {
                    const rows = Math.ceil(count / cols);
                    const totalCells = cols * rows;
                    
                    if (totalCells >= count) {
                        const emptyCells = totalCells - count;
                        
                        const cellWidth = screenWidth / cols;
                        const cellHeight = screenHeight / rows;
                        const cellAspect = cellWidth / cellHeight;
                        
                        const aspectScore = Math.abs(cellAspect - 1);
                        const gridAspectScore = Math.abs((cols/rows) - screenAspect);
                        const emptyScore = emptyCells * 10;
                        
                        const totalScore = aspectScore + gridAspectScore * 0.5 + emptyScore;
                        
                        if (totalScore < bestScore) {
                            bestScore = totalScore;
                            bestCols = cols;
                            bestRows = rows;
                            bestAreas = createOptimalAreas(count, cols, rows);
                        }
                    }
                }
                
                return { cols: bestCols, rows: bestRows, areas: bestAreas };
            }
            
            function createOptimalAreas(count, cols, rows) {
                const areas = [];
                const totalCells = cols * rows;
                const emptyCells = totalCells - count;
                
                if (emptyCells === 0) {
                    for (let i = 0; i < count; i++) {
                        const col = (i % cols) + 1;
                        const row = Math.floor(i / cols) + 1;
                        areas.push(`${row} / ${col} / ${row + 1} / ${col + 1}`);
                    }
                } else {
                    let imageIndex = 0;
                    
                    for (let row = 1; row <= rows; row++) {
                        for (let col = 1; col <= cols; col++) {
                            if (imageIndex < count) {
                                const remainingImages = count - imageIndex;
                                const remainingCells = (rows - row) * cols + (cols - col + 1);
                                
                                if (remainingImages < remainingCells) {
                                    const spanCols = Math.min(cols - col + 1, Math.ceil(remainingCells / remainingImages));
                                    const spanRows = row === rows ? 1 : Math.min(rows - row + 1, Math.ceil(remainingCells / remainingImages / spanCols));
                                    
                                    areas.push(`${row} / ${col} / ${row + spanRows} / ${col + spanCols}`);
                                    imageIndex++;
                                    col += spanCols - 1;
                                } else {
                                    areas.push(`${row} / ${col} / ${row + 1} / ${col + 1}`);
                                    imageIndex++;
                                }
                            }
                        }
                    }
                }
                
                return areas;
            }
            
            // Focus/unfocus image
            function focusImage(index) {
                if (focusedIndex === index) {
                    closeFocus();
                    return;
                }
                
                focusedIndex = index;
                const containers = document.querySelectorAll('.image-container');
                
                containers.forEach((container, i) => {
                    if (i === index) {
                        container.classList.add('focused');
                    } else {
                        container.style.opacity = '0.3';
                    }
                });
                
                moodboard.classList.add('blurred');
                updateImageCounter();
                showStatus('Press ESC or click to close');
            }
            
            function closeFocus() {
                focusedIndex = -1;
                const containers = document.querySelectorAll('.image-container');
                
                containers.forEach(container => {
                    container.classList.remove('focused');
                    container.style.opacity = '1';
                });
                
                moodboard.classList.remove('blurred');
            }
            
            function navigateFocus(direction) {
                if (focusedIndex === -1) return;
                
                let newIndex = focusedIndex + direction;
                if (newIndex < 0) newIndex = images.length - 1;
                if (newIndex >= images.length) newIndex = 0;
                
                focusImage(newIndex);
            }
            
            function updateImageCounter() {
                imageCounter.textContent = `${focusedIndex + 1} / ${images.length}`;
            }
            
            // Handle keyboard events
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    closeFocus();
                } else if (focusedIndex !== -1) {
                    if (e.key === 'ArrowLeft') {
                        navigateFocus(-1);
                    } else if (e.key === 'ArrowRight') {
                        navigateFocus(1);
                    }
                }
            });
            
            // Handle paste event
            document.addEventListener('paste', async function(e) {
                const items = e.clipboardData.items;
                let imageFound = false;
                
                for (let item of items) {
                    if (item.type.indexOf('image') !== -1) {
                        imageFound = true;
                        const file = item.getAsFile();
                        await processImageFile(file);
                    }
                }
                
                if (!imageFound) {
                    showStatus('No image found in clipboard');
                }
            });
            
            // Enhanced drag and drop for external sources
            document.addEventListener('dragenter', function(e) {
                e.preventDefault();
                if (!e.target.closest('.image-container')) {
                    dragOverlay.classList.add('active');
                }
            });
            
            document.addEventListener('dragover', function(e) {
                e.preventDefault();
                if (!e.target.closest('.image-container')) {
                    dragOverlay.classList.add('active');
                }
            });
            
            document.addEventListener('dragleave', function(e) {
                if (!e.relatedTarget || e.relatedTarget === null) {
                    dragOverlay.classList.remove('active');
                }
            });
            
            document.addEventListener('drop', async function(e) {
                e.preventDefault();
                dragOverlay.classList.remove('active');
                
                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    const files = e.dataTransfer.files;
                    let imageFound = false;
                    
                    for (let file of files) {
                        if (file.type.indexOf('image') !== -1) {
                            imageFound = true;
                            await processImageFile(file);
                        }
                    }
                    
                    if (!imageFound) {
                        showStatus('No image files found');
                    }
                    return;
                }
                
                if (e.dataTransfer.types.includes('text/uri-list')) {
                    const url = e.dataTransfer.getData('text/uri-list');
                    if (url && isImageUrl(url)) {
                        await addImageFromUrl(url);
                    }
                    return;
                }
            });
            
            // Check if URL points to an image
            function isImageUrl(url) {
                return /\.(jpg|jpeg|png|webp|gif|bmp|svg)$/i.test(url) || 
                       url.startsWith('data:image/');
            }
            
            // Add image from URL
            async function addImageFromUrl(url) {
                showStatus('Loading image...');
                
                try {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    const imageData = await new Promise((resolve, reject) => {
                        img.onload = function() {
                            const canvas = document.createElement('canvas');
                            canvas.width = Math.min(img.width, 1200);
                            canvas.height = Math.min(img.height, 1200);
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                            
                            let compressedData;
                            try {
                                compressedData = canvas.toDataURL('image/webp', 0.7);
                            } catch (e) {
                                compressedData = canvas.toDataURL('image/jpeg', 0.7);
                            }
                            
                            resolve(compressedData);
                        };
                        
                        img.onerror = () => reject(new Error('Failed to load image'));
                        img.src = url;
                    });
                    
                    addImageToMoodboard(imageData);
                    showStatus('Image added');
                } catch (error) {
                    showStatus('Error loading image');
                }
            }
            
            // Process image file
            async function processImageFile(file) {
                if (file.size > 2000000) {
                    showStatus('Image too large');
                    return;
                }
                
                const reader = new FileReader();
                
                return new Promise((resolve) => {
                    reader.onload = async function(e) {
                        const imageData = e.target.result;
                        
                        const img = new Image();
                        img.onload = function() {
                            const canvas = document.createElement('canvas');
                            canvas.width = Math.min(img.width, 1200);
                            canvas.height = Math.min(img.height, 1200);
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                            
                            let compressedData;
                            try {
                                compressedData = canvas.toDataURL('image/webp', 0.7);
                            } catch (e) {
                                compressedData = canvas.toDataURL('image/jpeg', 0.7);
                            }
                            
                            addImageToMoodboard(compressedData);
                            resolve();
                        };
                        img.src = imageData;
                    };
                    
                    reader.onerror = () => {
                        showStatus('Error loading image');
                        resolve();
                    };
                    
                    reader.readAsDataURL(file);
                });
            }
            
            // Add image to moodboard
            function addImageToMoodboard(imageData) {
                images.push(imageData);
                renderMoodboard();
                showStatus(`Image ${images.length} added`);
            }
            
            // Render moodboard
            function renderMoodboard() {
                if (images.length === 0) {
                    moodboard.innerHTML = '';
                    moodboard.style.backgroundColor = '#000';
                    return;
                }
                
                moodboard.innerHTML = '';
                closeFocus(); // Close any open focus when re-rendering
                
                const layout = calculatePerfectLayout(images.length);
                moodboard.style.gridTemplateColumns = `repeat(${layout.cols}, 1fr)`;
                moodboard.style.gridTemplateRows = `repeat(${layout.rows}, 1fr)`;
                
                images.forEach((imageData, index) => {
                    const imageContainer = document.createElement('div');
                    imageContainer.className = 'image-container';
                    imageContainer.setAttribute('data-index', index);
                    
                    if (layout.areas[index]) {
                        imageContainer.style.gridArea = layout.areas[index];
                    }
                    
                    const img = document.createElement('img');
                    img.src = imageData;
                    img.alt = `Image ${index + 1}`;
                    img.draggable = false;
                    
                    const imageControls = document.createElement('div');
                    imageControls.className = 'image-controls';
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = '×';
                    deleteBtn.title = 'Delete image';
                    deleteBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        images.splice(index, 1);
                        renderMoodboard();
                        showStatus('Image removed');
                    });
                    
                    const focusBtn = document.createElement('button');
                    focusBtn.innerHTML = '🔍';
                    focusBtn.title = 'Focus image';
                    focusBtn.className = 'focus-btn';
                    focusBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        focusImage(index);
                    });
                    
                    // Click on container to focus
                    imageContainer.addEventListener('click', function(e) {
                        if (!e.target.closest('.image-controls')) {
                            focusImage(index);
                        }
                    });
                    
                    // Drag functionality
                    imageContainer.addEventListener('mousedown', startDrag);
                    
                    imageControls.appendChild(focusBtn);
                    imageControls.appendChild(deleteBtn);
                    imageContainer.appendChild(img);
                    imageContainer.appendChild(imageControls);
                    moodboard.appendChild(imageContainer);
                });
            }
            
            // Drag and drop functionality
            function startDrag(e) {
                if (focusedIndex !== -1) return; // Don't drag when focused
                
                e.preventDefault();
                const index = parseInt(e.currentTarget.getAttribute('data-index'));
                draggedIndex = index;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                
                document.addEventListener('mousemove', handleDrag);
                document.addEventListener('mouseup', stopDrag);
            }
            
            function handleDrag(e) {
                const dx = Math.abs(e.clientX - dragStartX);
                const dy = Math.abs(e.clientY - dragStartY);
                
                if (dx > DRAG_THRESHOLD || dy > DRAG_THRESHOLD) {
                    e.currentTarget.classList.add('dragging');
                }
            }
            
            function stopDrag(e) {
                document.removeEventListener('mousemove', handleDrag);
                document.removeEventListener('mouseup', stopDrag);
                
                const containers = document.querySelectorAll('.image-container');
                containers.forEach(container => container.classList.remove('dragging'));
                
                if (draggedIndex !== null) {
                    const finalX = e.clientX;
                    const finalY = e.clientY;
                    
                    if (finalX && finalY) {
                        const element = document.elementFromPoint(finalX, finalY);
                        if (element && element.closest('.image-container')) {
                            const targetContainer = element.closest('.image-container');
                            const targetIndex = parseInt(targetContainer.getAttribute('data-index'));
                            
                            if (draggedIndex !== targetIndex && targetIndex < images.length) {
                                const movedImage = images.splice(draggedIndex, 1)[0];
                                images.splice(targetIndex, 0, movedImage);
                                renderMoodboard();
                                showStatus('Image moved');
                            }
                        }
                    }
                }
                
                draggedIndex = null;
            }
            
            // Clear all images
            document.addEventListener('keydown', function(e) {
                if (e.ctrlKey && e.key === 'Delete') {
                    if (images.length > 0 && confirm('Clear all images?')) {
                        images = [];
                        renderMoodboard();
                        showStatus('All images cleared');
                    }
                }
            });
            
            // Recalculate grid on window resize
            window.addEventListener('resize', function() {
                if (images.length > 0) {
                    renderMoodboard();
                }
            });
            
            // Prevent default drag behavior
            document.addEventListener('dragstart', function(e) {
                e.preventDefault();
            });
            
            // Global functions for navigation
            window.navigateFocus = navigateFocus;
            window.closeFocus = closeFocus;
            
            // Initial empty state
            renderMoodboard();
        });
    </script>
</body>
</html>