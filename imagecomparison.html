<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Image Comparison</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: black;
    overflow: hidden;
    height: 100%;
    width: 100%;
    display: flex;
    flex-direction: column;
  }
  canvas {
    flex: 1;
    display: block;
    cursor: crosshair;
  }
  .controls {
    background: #111;
    color: white;
    text-align: center;
    padding: 8px;
  }
  button {
    background: #222;
    border: 1px solid white;
    color: white;
    padding: 6px 12px;
    margin: 0 6px;
    cursor: pointer;
  }
  button:hover {
    background: #333;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div class="controls">
  <button id="toggleAuto">Start Auto Transition</button>
  <button id="recenter">Recenter + Fit</button>
  <span style="margin-left:12px;">ðŸ’¡ Hover to preview, scroll to zoom, drag to move, paste/drag-drop to load images.</span>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { alpha: false });
ctx.imageSmoothingEnabled = false;

let img1 = new Image();
let img2 = new Image();
let img1Loaded = false, img2Loaded = false;

let scale = 1, fitScale = 1;
let panX = 0, panY = 0;
let transitionRatio = 0.5; // 0 = left edge, 1 = right edge
let auto = false;
let autoDirection = 1;

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight - document.querySelector('.controls').offsetHeight;
  fitToScreen();
}
window.addEventListener('resize', resizeCanvas);

function fitToScreen() {
  if (!(img1Loaded || img2Loaded)) return;
  const img = img1Loaded ? img1 : img2;
  const scaleX = canvas.width / img.width;
  const scaleY = canvas.height / img.height;
  fitScale = Math.min(scaleX, scaleY);
  scale = fitScale;
  panX = 0; panY = 0;
  transitionRatio = 0.5;
}
document.getElementById('recenter').onclick = fitToScreen;

function getDisplayBounds() {
  if (!(img1Loaded || img2Loaded)) return {left:0,right:canvas.width,top:0,bottom:canvas.height,width:canvas.width};
  const img = img1Loaded ? img1 : img2;
  const displayWidth = img.width * scale;
  const displayHeight = img.height * scale;
  const offsetX = (canvas.width - displayWidth) / 2 + panX;
  const offsetY = (canvas.height - displayHeight) / 2 + panY;
  return {left: offsetX, right: offsetX + displayWidth, top: offsetY, bottom: offsetY + displayHeight, width: displayWidth};
}

function drawImages() {
  ctx.imageSmoothingEnabled = false; // ensure pixelated each frame
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (!(img1Loaded || img2Loaded)) return;

  const bounds = getDisplayBounds();
  const dividerX = bounds.left + transitionRatio * bounds.width;

  if (img2Loaded) ctx.drawImage(img2, bounds.left, bounds.top, bounds.width, bounds.bottom - bounds.top);
  if (img1Loaded) {
    ctx.save();
    ctx.beginPath();
    ctx.rect(bounds.left, bounds.top, dividerX - bounds.left, bounds.bottom - bounds.top);
    ctx.clip();
    ctx.drawImage(img1, bounds.left, bounds.top, bounds.width, bounds.bottom - bounds.top);
    ctx.restore();
  }

  ctx.strokeStyle = "white";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(dividerX, bounds.top);
  ctx.lineTo(dividerX, bounds.bottom);
  ctx.stroke();
}

canvas.addEventListener('mousemove', e => {
  if (!auto) {
    const bounds = getDisplayBounds();
    transitionRatio = (e.offsetX - bounds.left) / bounds.width;
    transitionRatio = Math.max(0, Math.min(1, transitionRatio));
  }
});

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
  scale *= zoomFactor;
  drawImages();
});

let isDragging = false;
let lastX, lastY;
canvas.addEventListener('mousedown', e => {
  isDragging = true;
  lastX = e.clientX;
  lastY = e.clientY;
});
window.addEventListener('mouseup', () => { isDragging = false; });
window.addEventListener('mousemove', e => {
  if (isDragging) {
    panX += e.clientX - lastX;
    panY += e.clientY - lastY;
    lastX = e.clientX;
    lastY = e.clientY;
  }
});

function update() {
  if (auto && (img1Loaded || img2Loaded)) {
    const bounds = getDisplayBounds();

    // compute visible horizontal range
    const visibleLeft = Math.max(bounds.left, 0);
    const visibleRight = Math.min(bounds.right, canvas.width);

    const minRatio = (visibleLeft - bounds.left) / bounds.width;
    const maxRatio = (visibleRight - bounds.left) / bounds.width;

    transitionRatio += autoDirection * 0.002;
    if (transitionRatio > maxRatio) { transitionRatio = maxRatio; autoDirection = -1; }
    if (transitionRatio < minRatio) { transitionRatio = minRatio; autoDirection = 1; }
  }
  drawImages();
  requestAnimationFrame(update);
}
update();

document.getElementById('toggleAuto').onclick = () => {
  auto = !auto;
  document.getElementById('toggleAuto').innerText = auto ? "Stop Auto Transition" : "Start Auto Transition";
};

function handleFiles(files) {
  [...files].forEach(file => {
    if (!file.type.startsWith("image/")) return;
    const reader = new FileReader();
    reader.onload = e => {
      const img = new Image();
      img.onload = () => {
        if (!img1Loaded) { img1 = img; img1Loaded = true; }
        else if (!img2Loaded) { img2 = img; img2Loaded = true; }
        else { img1 = img; img1Loaded = true; img2Loaded = false; }
        fitToScreen();
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  });
}

window.addEventListener('paste', e => {
  if (e.clipboardData.files.length) handleFiles(e.clipboardData.files);
});
canvas.addEventListener('dragover', e => { e.preventDefault(); });
canvas.addEventListener('drop', e => {
  e.preventDefault();
  if (e.dataTransfer.files.length) handleFiles(e.dataTransfer.files);
});

resizeCanvas();
</script>
</body>
</html>
