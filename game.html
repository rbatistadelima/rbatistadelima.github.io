<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Jogo Top-Down Emoji</title>
<style>
    * {margin:0; padding:0; box-sizing:border-box;}
    body, html {width:100%; height:100%; overflow:hidden; font-family:Comic Sans MS, cursive, sans-serif;}
    canvas {display:block; margin:0 auto; touch-action: none;}
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const size = 50; // tamanho padrÃ£o dos emojis

let keys = {};
let mouse = {x:0, y:0, down:false};
let touches = {};
const isMobile = /Mobi|Android/i.test(navigator.userAgent);

class Entity {
    constructor(x, y, emoji){
        this.x = x;
        this.y = y;
        this.emoji = emoji;
        this.width = size;
        this.height = size;
    }
    draw(opacity=1){
        ctx.save();
        ctx.globalAlpha = opacity;
        ctx.shadowColor = 'rgba(0,0,0,0.7)';
        ctx.shadowOffsetX = 5;
        ctx.shadowOffsetY = 5;
        ctx.shadowBlur = 0;
        ctx.font = `${this.width}px Arial`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(this.emoji, this.x, this.y);
        ctx.restore();
    }
}

class Player extends Entity {
    constructor(x, y){
        super(x, y, 'ðŸ˜€');
        this.speed = 5;
        this.vx = 0;
        this.vy = 0;
        this.maxHealth = 100;
        this.health = this.maxHealth;
        this.shootCooldown = 0;
        this.hitTimer = 0;
        this.dead = false;
    }
    update(){
        if(this.dead) return;

        // Movimento teclado (PC)
        this.vx = 0; this.vy = 0;
        if(!isMobile){
            if(keys['ArrowUp'] || keys['w']) this.vy = -this.speed;
            if(keys['ArrowDown'] || keys['s']) this.vy = this.speed;
            if(keys['ArrowLeft'] || keys['a']) this.vx = -this.speed;
            if(keys['ArrowRight'] || keys['d']) this.vx = this.speed;
        }

        // Movimento touch (Mobile)
        if(isMobile){
            for(let id in touches){
                let t = touches[id];
                let dx = t.x - this.x;
                let dy = t.y - this.y;
                let dist = Math.hypot(dx, dy);
                if(dist>1){
                    this.vx = (dx/dist)*this.speed;
                    this.vy = (dy/dist)*this.speed;
                }
            }
        }

        this.x += this.vx;
        this.y += this.vy;

        // Limites da tela
        this.x = Math.max(size/2, Math.min(canvas.width-size/2, this.x));
        this.y = Math.max(size/2, Math.min(canvas.height-size/2, this.y));

        // Tiros
        if(((!isMobile && keys[' ']) || (isMobile && Object.keys(touches).length>0)) && this.shootCooldown <=0){
            this.shoot();
            this.shootCooldown = 15;
        }
        if(this.shootCooldown>0) this.shootCooldown--;

        // MudanÃ§a de emoji
        if(this.hitTimer>0){
            this.emoji = 'ðŸ˜–';
            this.hitTimer--;
        } else if(this.shootCooldown>0){
            this.emoji = 'ðŸ¤«';
        } else{
            this.emoji = 'ðŸ˜€';
        }

        if(this.health <=0 && !this.dead){
            this.emoji = 'ðŸ˜­';
            this.dead = true;
        }
    }
    draw(){
        super.draw();
        // fundo da barra de vida
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x-size/2-1, this.y-size-1, size+2, 7);
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.strokeRect(this.x-size/2-1, this.y-size-1, size+2, 7);

        // barra verde
        ctx.fillStyle = 'green';
        ctx.fillRect(this.x-size/2, this.y-size, size*(this.health/this.maxHealth), 5);
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.strokeRect(this.x-size/2, this.y-size, size*(this.health/this.maxHealth), 5);

        // nÃºmero da vida
        ctx.font = `bold 16px Comic Sans MS`;
        ctx.textAlign = 'center';
        ctx.fillStyle = 'white';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.strokeText(this.health, this.x, this.y-size-10);
        ctx.fillText(this.health, this.x, this.y-size-10);
    }
    shoot(){
        let dx = mouse.x - this.x;
        let dy = mouse.y - this.y;
        let angle = Math.atan2(dy, dx);
        bullets.push(new Bullet(this.x, this.y, angle));
    }
    takeDamage(amount){
        this.health -= amount;
        this.hitTimer = 120; // 2 segundos
        if(this.health<=0) this.health = 0;
    }
}

class Bullet extends Entity {
    constructor(x, y, angle){
        super(x, y, 'ðŸ”¥');
        this.speed = 10;
        this.angle = angle;
        this.flip = false;
        this.flipTimer = 0;
        this.life = 180; // 3 segundos a 60fps
    }
    update(){
        this.x += Math.cos(this.angle)*this.speed;
        this.y += Math.sin(this.angle)*this.speed;

        this.flipTimer++;
        if(this.flipTimer%10===0) this.flip = !this.flip;

        this.life--;
        if(this.life<=0){
            bullets.splice(bullets.indexOf(this),1);
        }
    }
    draw(){
        let opacity = this.life/180; // fade
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle + Math.PI); // 180Â°
        ctx.scale(this.flip?-1:1,1);
        ctx.shadowColor = 'rgba(0,0,0,0.7)';
        ctx.shadowOffsetX = 5;
        ctx.shadowOffsetY = 5;
        ctx.shadowBlur = 0;
        ctx.globalAlpha = opacity;
        ctx.font = `${size}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.emoji,0,0);
        ctx.restore();
    }
}

class Enemy extends Entity {
    constructor(x, y){
        super(x, y, 'ðŸ•·');
        this.speed = 2;
        this.angle = 0;
        this.dead = false;
    }
    update(){
        if(this.dead) return;
        let dx = player.x - this.x;
        let dy = player.y - this.y;
        let dist = Math.hypot(dx, dy);
        this.angle = Math.atan2(dy, dx);
        this.x += (dx/dist)*this.speed;
        this.y += (dy/dist)*this.speed;

        if(dist<size){
            player.takeDamage(10);
            this.dead = true;
            explosions.push(new Explosion(this.x,this.y));
        }
    }
    draw(){
        if(this.dead) return;
        ctx.save();
        ctx.translate(this.x,this.y);
        ctx.rotate(this.angle);
        ctx.shadowColor = 'rgba(0,0,0,0.7)';
        ctx.shadowOffsetX = 5;
        ctx.shadowOffsetY = 5;
        ctx.shadowBlur = 0;
        ctx.font = `${size}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.emoji,0,0);
        ctx.restore();
    }
}

class Explosion extends Entity {
    constructor(x,y){
        super(x,y,'ðŸ’¥');
        this.life = 180; // 3 segundos
    }
    update(){
        this.life--;
        if(this.life<=0) explosions.splice(explosions.indexOf(this),1);
    }
    draw(){
        let opacity = this.life/180;
        super.draw(opacity);
    }
}

const player = new Player(canvas.width/2, canvas.height/2);
const bullets = [];
const enemies = [];
const explosions = [];

function spawnEnemy(){
    let corners = [
        [size/2,size/2],
        [canvas.width-size/2,size/2],
        [size/2,canvas.height-size/2],
        [canvas.width-size/2,canvas.height-size/2]
    ];
    let c = corners[Math.floor(Math.random()*4)];
    enemies.push(new Enemy(c[0],c[1]));
}
setInterval(spawnEnemy, 2000);

window.addEventListener('keydown', e=>{keys[e.key]=true;});
window.addEventListener('keyup', e=>{keys[e.key]=false;});

// Touch Mobile
canvas.addEventListener('touchstart', e=>{
    if(isMobile){
        for(let t of e.touches){
            touches[t.identifier]={x:t.clientX, y:t.clientY};
        }
    }
});
canvas.addEventListener('touchmove', e=>{
    if(isMobile){
        touches={};
        for(let t of e.touches){
            touches[t.identifier]={x:t.clientX, y:t.clientY};
        }
    }
});
canvas.addEventListener('touchend', e=>{
    if(isMobile){
        touches={};
    }
});

function loop(){
    ctx.fillStyle = 'green';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    enemies.forEach(enemy=>{enemy.update(); enemy.draw();});
    bullets.forEach(bullet=>{
        bullet.update();
        bullet.draw();
        enemies.forEach(enemy=>{
            if(!enemy.dead && Math.hypot(bullet.x-enemy.x, bullet.y-enemy.y)<size/1.5){
                enemy.dead = true;
                explosions.push(new Explosion(enemy.x, enemy.y));
                bullets.splice(bullets.indexOf(bullet),1);
            }
        });
    });
    player.update();
    player.draw();
    explosions.forEach(explosion=>{explosion.update(); explosion.draw();});

    requestAnimationFrame(loop);
}

loop();

window.addEventListener('resize', ()=>{
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});
</script>
</body>
</html>
