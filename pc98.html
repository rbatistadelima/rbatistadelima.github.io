<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>PC-98 Studio (WebGL 2 + Masks)</title>
<style>
html,body{margin:0;height:100%;background:#111;color:#eee;font-family:sans-serif;}
#ui{position:fixed;left:0;top:0;width:280px;height:100%;overflow:hidden;
    background:#222;padding:10px;display:flex;flex-direction:column;gap:6px;box-shadow:2px 0 6px #000;}
#glCanvas{position:fixed;left:280px;top:0;right:0;bottom:0;background:#000;
          image-rendering:pixelated;}
label{font-size:12px;margin-top:4px;}
input[type=range]{width:100%;}
button{background:#333;color:#eee;border:none;padding:5px 8px;margin-top:4px;border-radius:4px;}
button:hover{background:#444;}
.row{display:flex;gap:4px;}
</style>
</head>
<body>
<div id="ui">
  <h3>PC-98 Studio</h3>
  <label>Upload Image</label>
  <input type="file" id="fileInput" accept="image/*">

  <label>Brush Size</label>
  <input type="range" id="brushSize" min="1" max="64" value="16">
  <label>Brush Opacity</label>
  <input type="range" id="brushOpacity" min="0" max="1" step="0.01" value="0.5">
  <div class="row">
    <button id="lightMode">Lighten</button>
    <button id="darkMode">Darken</button>
  </div>
  <div class="row">
    <button id="undoBtn">Undo</button>
    <button id="redoBtn">Redo</button>
  </div>
  <button id="clearBtn">Clear Masks</button>

  <hr>
  <label>Brightness</label>
  <input type="range" id="brightness" min="-1" max="1" step="0.01" value="0">
  <label>Contrast</label>
  <input type="range" id="contrast" min="-1" max="1" step="0.01" value="0">
  <label>Saturation</label>
  <input type="range" id="saturation" min="0" max="2" step="0.01" value="1">

  <button id="downloadBtn">Download</button>
  <button id="resetBtn">Reset</button>
</div>

<canvas id="glCanvas" width="640" height="400"></canvas>

<script>
const glCanvas=document.getElementById("glCanvas");
const gl=glCanvas.getContext("webgl2");
if(!gl){alert("WebGL2 not supported");throw new Error("WebGL2 not supported");}

let img=null,baseTex=null,lightTex=null,darkTex=null;
let brushSize=16,brushOpacity=0.5,mode="light";
let undoStack=[],redoStack=[];
const maskSize={w:640,h:400};
const lightMask=document.createElement("canvas");
const darkMask=document.createElement("canvas");
lightMask.width=darkMask.width=maskSize.w;
lightMask.height=darkMask.height=maskSize.h;
const lctx=lightMask.getContext("2d");
const dctx=darkMask.getContext("2d");
function clearMasks(){lctx.clearRect(0,0,maskSize.w,maskSize.h);dctx.clearRect(0,0,maskSize.w,maskSize.h);}
clearMasks();

function pushUndo(){
  if(undoStack.length>20)undoStack.shift();
  undoStack.push({
    light:lctx.getImageData(0,0,maskSize.w,maskSize.h),
    dark:dctx.getImageData(0,0,maskSize.w,maskSize.h)
  });
  redoStack=[];
}
function restore(state){
  lctx.putImageData(state.light,0,0);
  dctx.putImageData(state.dark,0,0);
  uploadMasks();
  drawScene();
}
document.getElementById("undoBtn").onclick=()=>{
  if(!undoStack.length)return;
  redoStack.push({
    light:lctx.getImageData(0,0,maskSize.w,maskSize.h),
    dark:dctx.getImageData(0,0,maskSize.w,maskSize.h)
  });
  restore(undoStack.pop());
};
document.getElementById("redoBtn").onclick=()=>{
  if(!redoStack.length)return;
  undoStack.push({
    light:lctx.getImageData(0,0,maskSize.w,maskSize.h),
    dark:dctx.getImageData(0,0,maskSize.w,maskSize.h)
  });
  restore(redoStack.pop());
};

document.getElementById("brushSize").oninput=e=>brushSize=+e.target.value;
document.getElementById("brushOpacity").oninput=e=>brushOpacity=+e.target.value;
document.getElementById("lightMode").onclick=()=>mode="light";
document.getElementById("darkMode").onclick=()=>mode="dark";
document.getElementById("clearBtn").onclick=()=>{clearMasks();uploadMasks();drawScene();};

let painting=false;
glCanvas.addEventListener("mousedown",e=>{
  if(!img)return;
  pushUndo();painting=true;
  paintAt(e);
});
glCanvas.addEventListener("mousemove",e=>painting&&paintAt(e));
window.addEventListener("mouseup",()=>painting=false);

function paintAt(e){
  const rect=glCanvas.getBoundingClientRect();
  const x=(e.clientX-rect.left)*(maskSize.w/rect.width);
  const y=(e.clientY-rect.top)*(maskSize.h/rect.height);
  const ctx=(mode==="light"?lctx:dctx);
  ctx.globalAlpha=brushOpacity;
  ctx.fillStyle=mode==="light"?"white":"black";
  ctx.beginPath();ctx.arc(x,y,brushSize,0,Math.PI*2);ctx.fill();ctx.globalAlpha=1;
  uploadMasks();
  drawScene();
}

function makeTex(image){
  const tex=gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D,tex);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,image);
  return tex;
}

function uploadMasks(){
  if(!lightTex)lightTex=gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D,lightTex);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,lightMask);
  if(!darkTex)darkTex=gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D,darkTex);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,darkMask);
}

document.getElementById("fileInput").onchange=e=>{
  const file=e.target.files[0];
  if(!file)return;
  const reader=new FileReader();
  reader.onload=ev=>{
    img=new Image();
    img.onload=()=>{
      baseTex=makeTex(img);
      uploadMasks();
      drawScene();
    };
    img.src=ev.target.result;
  };
  reader.readAsDataURL(file);
};

document.getElementById("downloadBtn").onclick=()=>{
  const link=document.createElement("a");
  link.download="pc98_webgl.png";
  link.href=glCanvas.toDataURL();
  link.click();
};

document.getElementById("resetBtn").onclick=()=>{
  ["brightness","contrast"].forEach(id=>document.getElementById(id).value=0);
  document.getElementById("saturation").value=1;
  clearMasks();uploadMasks();drawScene();
};

/* ==== SHADER creation will come in Part 2 ==== */

// Vertex + fragment shaders
const vertSrc = `#version 300 es
precision mediump float;
layout(location=0) in vec2 pos;
out vec2 vUV;
void main() {
  vUV = (pos + 1.0) * 0.5;
  gl_Position = vec4(pos, 0.0, 1.0);
}`;

const fragSrc = `#version 300 es
precision mediump float;
in vec2 vUV;
out vec4 fragColor;

uniform sampler2D uBase;
uniform sampler2D uLight;
uniform sampler2D uDark;
uniform float uBrightness;
uniform float uContrast;
uniform float uSaturation;

// quantize to 6-bit per channel
vec3 quantize(vec3 c) {
  c = clamp(c, 0.0, 1.0);
  c = floor(c * 63.0 + 0.5) / 63.0;
  return c;
}

void main() {
  vec4 base = texture(uBase, vUV);
  vec3 light = texture(uLight, vUV).rgb;
  vec3 dark  = texture(uDark, vUV).rgb;

  // Apply lighten/darken masks (non-destructive)
  // white pixels = lighten, black = darken
  base.rgb = mix(base.rgb, vec3(1.0), light.r * 0.5);
  base.rgb = mix(base.rgb, vec3(0.0), dark.r * 0.5);

  // Basic color corrections
  vec3 col = base.rgb;
  col = (col + uBrightness);
  col = (col - 0.5) * (1.0 + uContrast) + 0.5;
  float avg = dot(col, vec3(0.3333));
  col = avg + (col - avg) * uSaturation;

  // Quantization (PC-98 look)
  col = quantize(col);

  // CRT scanlines + vignette
  float scan = 0.85 + 0.15 * sin(vUV.y * 800.0);
  float vign = smoothstep(1.0, 0.5, distance(vUV, vec2(0.5)) * 1.5);
  col *= scan * vign;

  fragColor = vec4(col, 1.0);
}`;

// Utility functions
function makeShader(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
    console.error(gl.getShaderInfoLog(s));
  return s;
}

function makeProgram(vs, fs) {
  const p = gl.createProgram();
  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS))
    console.error(gl.getProgramInfoLog(p));
  return p;
}

// Compile and link
const prog = makeProgram(makeShader(gl.VERTEX_SHADER, vertSrc),
                          makeShader(gl.FRAGMENT_SHADER, fragSrc));
gl.useProgram(prog);

// Full-screen quad
const quad = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quad);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1,-1, 1,-1, -1,1,  -1,1, 1,-1, 1,1
]), gl.STATIC_DRAW);
gl.enableVertexAttribArray(0);
gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

// Uniform handles
const uBase     = gl.getUniformLocation(prog,"uBase");
const uLight    = gl.getUniformLocation(prog,"uLight");
const uDark     = gl.getUniformLocation(prog,"uDark");
const uBright   = gl.getUniformLocation(prog,"uBrightness");
const uContrast = gl.getUniformLocation(prog,"uContrast");
const uSat      = gl.getUniformLocation(prog,"uSaturation");

// Ensure textures exist even before load
function emptyTex() {
  const t = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, t);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,maskSize.w,maskSize.h,0,
                gl.RGBA,gl.UNSIGNED_BYTE,null);
  return t;
}
baseTex = emptyTex(); lightTex = emptyTex(); darkTex = emptyTex();

// Draw function
function drawScene() {
  if(!baseTex)return;
  gl.viewport(0,0,glCanvas.width,glCanvas.height);
  gl.clearColor(0,0,0,1);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.useProgram(prog);
  gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, baseTex);
  gl.uniform1i(uBase,0);
  gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, lightTex);
  gl.uniform1i(uLight,1);
  gl.activeTexture(gl.TEXTURE2); gl.bindTexture(gl.TEXTURE_2D, darkTex);
  gl.uniform1i(uDark,2);

  gl.uniform1f(uBright, parseFloat(document.getElementById("brightness").value));
  gl.uniform1f(uContrast, parseFloat(document.getElementById("contrast").value));
  gl.uniform1f(uSat, parseFloat(document.getElementById("saturation").value));

  gl.drawArrays(gl.TRIANGLES,0,6);
}

// Animate
function animate(){
  requestAnimationFrame(animate);
  drawScene();
}
animate();
</script>
</body>
</html>
